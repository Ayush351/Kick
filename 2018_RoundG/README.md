productTriplet.cpp: The official solution is O(N^2) if we assume the time complexity of hashing is O(1), but hashing of a large number could take non trivial time. My approach here instead is a linear scan. Similar to the approach used in valid triangle number (https://leetcode.com/problems/valid-triangle-number/), we fix the first two number, and the third number (product of the first two numbers) can only increase as we increase the second number or the first number. 

combiningClasses.cpp: We do not need to build interval or segment tree for this question. We first convert all the intervals into starting events and ending events, and store the sorted events in a map. Then we iterate the map from the back to start to find the n th largest element. As we are iterating, we record the following three values: 1. the number of elements greater than the current value. 2. the most recent value that experienced a slope change 3. slope change: number of elements increased/decreased per unit. For example, if we have intervals \[3,4], \[2,3,4,5], we would iterate from value 5 to value 2. We would then notice a slope change from 1 element per unit to 2 element per unit as we move from value 5 to value 4. In this case, we would record the slope of change (2 element per unit at value 4), as well as value 4 where the slope of change takes place, and also number 1 (which tells us how many elements are greater than the current value, in this case only 5 is greater than 4, so we record 1). With these three values recorded, we can then use binary search on the first value (number of elements greater than current value) to locate the starting value (the second value we recorded), which is guranteed to be less than n (n is the n th element we want to find). And from there we can find the n th element by: n th value = starting value + ( n - starting value ) * slope . The total time complexity is n log n because both map takes log n for each insert and binary search takes log N for each find.    
