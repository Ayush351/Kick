ennergyStones.py: we cannot apply a direct dp because the order matters. Instead, we greedily compare two of the intervals and thus rank the priority of stones. Once the order is set, we can translate this problem to knapsack dp, similar to course schedule (https://leetcode.com/problems/course-schedule-iii/). What is so so special about this question is that we do not need to consider stones that have 0 energy (at the time of inspection)! Because for the sequence of stones we eat, we never eat a 0 energy stone (it is a waste of time), and thus we only need to consider the priority among the non-zero stones!

diverseSubarray.cpp: First thing to notice is that we cannot solve this in O(N) complexity with one prefix array. A O(N^2) solution inspects intervals with different left starting points. To reduce time complexity, we need to explore the relationships between intervals with different starting left points. Now, we can simulate the entire array as events, i.e. how many more we have gained or how many we have lost as we move along the interval, with a fixed left starting point. for example, if left starting point is 0, 114144 will be processed as 1,1,1,-2,1,-2, meaning that we gained 1, gained 1, gained 1, lost2 , gained 1 and lost 2. This is good enough if we start with left point fixed at 0. Now if we have our left starting point at 1, we would get 0,1,1,1,1,-2. We can observe that as we move our left point, only events with the same type as the left starting point are affected. Specifically, Here are the changes when we move our left starting point to the right by 1: the left starting point becomes 0, the initial -S becomes +1, and the first 0 becomes -S. This obeservation means that at most three updates are incurred with each move of left starting point. What about max prefix sum? When the left starting point is fixed, the max prefix sum is the best amount we can achieve. Here, we can finish the three updates and one retrieval of the max prefix sum in O(log N) complexity, with the help of a segment tree. In this implementation of segment tree, we update the numbers like a regular segment tree, but we also maintain the max prefix sum of each segment. If we call the max prefix sum of a segment M, the relationship is as follows: the max prefix sum of the parent segment = max( max prefix sum of left child segment, segment sum of left child + max prefix sum of right child segment). Last but not least, we can use binary search to find which three positions might need to be updated!
