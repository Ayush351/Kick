Parcels.py: The key is to realize how we can transform an optimization problem into decision problem. Since we only care about the extreme values, we only need to inspect the biggest or smallest of all possible values. 

contention.cpp: Like the previous problem we first transform it from an optimization problem to a decision problem. Now we binary search to find the optimal value of K. For each K, we want to see if there exists an order such that everying booking is at least K. Since we are looking at queries of the form intervals, similar to "meeting room (leetcode)" type of questions, we sort all of our queries as intervals, based on starting positions and ending positions. Now for each interval starting from the left to right, we want to determine its order of booking among all bookings. This can be found if we know the order of this interval relative to every other interval. Suppose we have two sorted intervals A and B, with interval A having a starting point earlier than interval B, and we would like to find the realtive order between A and B. There are three scenarios: 1. if interval B has a starting point later than A's ending point, then A and B won't affect each other and thus can be booked in any relative order. 2. If interval B has a starting point earlier than the ending point of A, (since B's starting point is later than A's starting point), B is a sub-interval of A, and thus must be booked before A, otherwise B would have no seat to book if A is booked first. 3. B has a starting point earlier than A's ending point and B's ending point is later than A's ending point. To deal with scenario 3, we procecess scenario 1 and 2 first. For interval A, let's first look at the other Q-1 intervals, and remove all sub-intervals of A. Suppose after removing all the sub intervals, interval A has M seats left. Now, we definitely want to keep at least K seats in this M seats for interval A. For all interval B in scenario 3, if it takes up more than M-K seats from the M seats of interval A, then interval B must be booked after A, i.e. interval B can only start after interval A has ended. Now what if interval B in scenario 3 takes less than M-K seats from the M seats in interval A? Let's say all of these intervals form a group G. Let the earliest starting point of group G be T. For all intervals in group G, since they are sorted based on starting point, we know that any interval starting from T or onwards will not take more than M-K intervals from A, and thus if A takes the first K seats from the M seats, all intervals in group G will not be affected and A still has at least K seats booked. What this means is that all intervals of group G can be booked before interval A, and A will have at least K seats left. To determine whether a scenario 3 interval is in group G or not, we can simply compare its starting point with T: if B has starting point after T, then it is in G. If B takes more than M-K seats, then it must have a starting point before T. Note that T must happend after A has taken K seats. In conclusion, what we are dicussing here is that for scenario 3, the most greedy (optimal) way for interval A to have at least K seats is to take the first K seats from the M reamining seat! Because in this way we can give all intervals in group G priority, i.e. all intervals of G can be taken before A and thus optimize their bookings. With this concusion, we can sweep all interval A from left to right and determine if the optimal condions can be met!
