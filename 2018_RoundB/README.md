noNine.py: For each number that does not contain digit 9, it can be interpreted as a base 9 number, let us denote this base 9 number as N. For each bound, we can find how many base 9 numbers are smaller than N (the base 9 represenation of bound). In these base 9 numbers smaller than N, 8 out of 9 of the numbers are not divisible 9. 

sherlockAndBitStrings.cpp: For dynamica programming approach, we move from end of N to start of N. We maintain a 16 bit (not 15 bit as opposed to official analysis) window at position i to document, given the formation of the last 15 bits and our choice of the 16th bit, how many ways there are to form bit strings starting from the i+1 th bit to the end. The recursion is that, dp\[i]\[state]=dp\[i+1]\[(state<<1)]+dp\[i+1]\[(state<<1)+1]. Remember that there might be too many ways and the numbers could overflow a long long type. So we cut the limit at 1e18.
