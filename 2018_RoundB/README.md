noNine.py: For each number that does not contain digit 9, it can be interpreted as a base 9 number, let us denote this base 9 number as N. For each bound, we can find how many base 9 numbers are smaller than N (the base 9 represenation of bound). In these base 9 numbers smaller than N, 8 out of 9 of the numbers are not divisible 9. 

sherlockAndBitStrings.cpp: For dynamica programming approach, we move from end of N to start of N. We maintain a 16 bit (not 15 bit as opposed to official analysis) window at position i to document, given the formation of the last 15 bits and our choice of the 16th bit, how many ways there are to form bit strings starting from the i+1 th bit to the end. The recursion is that, dp\[i]\[state]=dp\[i+1]\[(state<<1)]+dp\[i+1]\[(state<<1)+1]. Remember that there might be too many ways and the numbers could overflow a long long type. So we cut the limit at 1e18.

kingsCircle.cpp: finish two test cases in less than a minute. The key observation is that a triplet will not form a valid square if one of the points is strictly inside the bounding box formed by the other two points. For each point, we count how many points are to the upper left, upper right, lower left and lower right of it. We maintain two segment trees, "tree" records v values which have corresponding h values bigger than the current point, and "smallTree" records v values which have corresponding h values smaller than the current point. As we can through h,v pairs, we increased h by one at a time, pop the current pair from "tree" and add it to "smallTree".
